import DestinationServer.Test_Server;
import Server.*;
import Server.BD.BD;

import java.io.IOException;

public class Test {

    /*
    * Server - содержит ThreadPoolExecutor  с фиксированным количеством подключений, по-умолчанию 1000, в случае если threadpoolexecutor заполнен ,
    * а приходит более чем 1 новое соединение очередь соединений обнуляется. После start() сервера запрещаются любые его настройки, кроме
    * установки нового ThreadPool. Синглтон.
    *
    * BD - база данных пользователей username/password, для socks4 id=полученное id, password=socks4. Добавление записей
    *  и очистка не потокобезопасны, только главный поток может добавлять пользователя. проверка пользователя - потокобезопасна.
    *
    * ThreadPool - пул селекторов - каждый селектор может обрабатывать до MAX_SELECTOR_PER_THREAD подключений, по-умолчанию - 100.
    * работает в поток-0. Если подключение больше не обрабатывается, счетчик уменьшается, доступ к добавлению новых ключей - потокобезопасен,
    * в случае ошибки требует завершения всех потоков-селекторов
    *
    * MySelector - Runnable класс, содержит селектор и потокобезопасные методы добавления новых ключей,
    * каждый экземпляр работает в отдельном потоке (поток-1), в случае прерывания требует закрытия селектора.
    * с помощью флагов органищует потокобезопасный доступ к функциям добавления, То есть обработка select() прерывается на время добаления
    * нового ключа.
    *
    * Task - получает начальный пакет, анализирует первый байт и в соответсвии с ним выбирает либо socks5, либо socks4.
    * каждая задача работает в отдельном потоке (поток-2).Взаиможействие поток-1 и поток-2 организовано через выставление флагов
    * в потоке-2 и ReentrantLock и Condition.В случае ошибки закрывает открытый конект с клиентом, и выводит сообщение об ошибке.
    *
    * Socks4/5 - в соответсвии со стандартом парсит пакеты в блокирующем режиме, организует подключение к серверу назначения,
    * если при парсинге происходит исключение, то закрывает открытые сокеты и пробрасывает End,
    * переводит каналы в неблокирующий режим, регистрирует их в селекторах - могут попасть в разные потоки-1, переходит в режим ожидания,
    * ждет сигнала от потока-1 ровно timeout миллесекунд, если такого сигнала не последовало, то закрывает соединение без ошибки.
    *
    *
    * MySelector.Readable - при получении select'ом ключей проверяет является ли данный ключ риадабл, елси да то парсит аатачмент ключа
    * в атачменте хранится пара - (текущая задача которой принадлежат селекторы, канал в который будет производися запись),
    * in, out - входящий и исходящий каналы. пытается считать байты с in , если получает ошибку, то посылает сигнал task, что надо завершить работу
    * Иначе пока может читать -  читает, а после отправляет в out. Выставление флагов в задаче (поток-2) безопасно.
    *
    *
    * */

    public static void main(String[] args) {
        //Append user ID or User Id and Password to connect with authorization
        BD.getInstance().appendUser("vizir","vadim");
        //Set MAX CONNECTION for SERVER
        int MAX_CONNECTION = 4;
        //Set requirement port for SERVER
        int PORT = Integer.parseInt(args[0]);

        Server server = Server.getInstance();
        //Server server = new Server(PORT, MAX_CONNECTION);

        //Undo for start test server, packet for test server have been sending by test client

        Thread thread = new Thread(new Test_Server());
        thread.start();

        try {
            server.configurate();
            server.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
